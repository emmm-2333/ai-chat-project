# 📘 从零打造 DeepSeek AI 聊天助手：全栈开发实战教程

> **写在前面**：本教程专为**完全新手**设计。我们将不只是复制代码，而是深入讲解**为什么**这么做。你将亲手构建一个类似 DeepSeek 官网的 AI 聊天应用，从获取 API Key 到前后端代码实现，再到最终运行。

---

## 目录 (Table of Contents)

1. [🌟 第一阶段：前期准备 - 磨刀不误砍柴工](#-第一阶段前期准备---磨刀不误砍柴工)
2. [⚙️ 第二阶段：后端开发 - 构建强大的心脏 (Spring Boot)](#️-第二阶段后端开发---构建强大的心脏-spring-boot)
    * [2.1 数据库设计](#21-数据库设计-给数据一个家)
    * [2.2 核心业务逻辑 (流式响应解密)](#22-核心业务逻辑-流式响应解密)
    * [2.3 API 接口暴露](#23-api-接口暴露)
3. [🎨 第三阶段：前端开发 - 打造精美的外观 (Vue 3)](#-第三阶段前端开发---打造精美的外观-vue-3)
    * [3.1 界面布局 (仿 DeepSeek)](#31-界面布局-仿-deepseek)
    * [3.2 核心交互逻辑 (Fetch流式读取)](#32-核心交互逻辑-fetch流式读取)
    * [3.3 主题切换 (深色模式)](#33-主题切换-深色模式)
4. [🚀 第四阶段：项目运行与调试](#-第四阶段项目运行与调试)
5. [🧠 深度解析：技术背后的原理](#-深度解析技术背后的原理)

---

## 🌟 第一阶段：前期准备 - 磨刀不误砍柴工

### 1.1 获取 DeepSeek API Key

1. **注册账号**: 访问 [DeepSeek 开放平台 (platform.deepseek.com)](https://platform.deepseek.com/) 并注册。
2. **创建 API Key**:
    * 点击左侧菜单的 **API Keys**。
    * 点击 **Create API Key**。
    * **重要**: 复制并保存生成的 `sk-` 开头的字符串。它只显示一次！
3. **配置到项目**:
    * 在项目根目录下，找到（或创建）目录：`backend/secrets/deepseek/`。
    * 新建一个名为 `api-key` 的文件（**注意：没有 .txt 后缀**）。
    * 将你的 Key 粘贴进去，不要有空格或换行。

> **为什么要用文件存 Key？**
> 直接把 Key 写在代码里（硬编码）是非常危险的。如果代码不小心上传到 GitHub，别人就能盗用你的额度。Spring Boot 支持从文件读取配置，这样 Key 就不在代码里了。

### 1.2 必备工具清单

请确保你的电脑上安装了以下软件：

| 工具 | 版本要求 | 作用 | 下载地址 |
| :--- | :--- | :--- | :--- |
| **JDK** | 21+ | 后端代码运行环境 | [Oracle JDK](https://www.oracle.com/java/technologies/downloads/) |
| **Node.js**| 18+ | 前端代码运行环境 | [Node.js 官网](https://nodejs.org/) |
| **MySQL** | 8.0+ | 数据库，存聊天记录 | [MySQL 官网](https://dev.mysql.com/downloads/) |
| **IDE** | IDEA / VS Code | 写代码的工具 | [IntelliJ IDEA](https://www.jetbrains.com/idea/) |

---

## ⚙️ 第二阶段：后端开发(Spring Boot)

后端负责处理业务逻辑、存储数据以及和 DeepSeek 接口交互。

### 2.1 数据库设计 

我们需要两张表：一张存“对话列表”，一张存“具体的聊天消息”。

**表结构设计 (schema.sql)**:

```sql
-- 会话表：记录每一个聊天窗口（如 "New Chat 1", "关于Java的问题"）
CREATE TABLE conversation (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL,       -- 归属用户（目前简易版默认都是用户1）
    title VARCHAR(255) NOT NULL,   -- 会话标题
    created_at DATETIME...
);

-- 消息表：记录具体的对话内容
CREATE TABLE message (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    conversation_id BIGINT NOT NULL, -- 属于哪个会话
    role VARCHAR(20) NOT NULL,       -- 角色：'user'(用户) 或 'assistant'(AI)
    content TEXT NOT NULL,           -- 聊天内容
    ...
);
```

### 2.2 核心业务逻辑 (流式响应)

这是全项目最难也最精彩的部分：**如何实现打字机效果？**

传统的 HTTP 请求是“说完才发”：服务器生成完所有文字，打包成一个 JSON 发给前端。这会让用户等很久。
我们要用 **SSE (Server-Sent Events)** 技术，实现“边想边发”：服务器每生成一个字，就推送到前端。

**核心代码 (ChatService.java)**:

```java
// 返回类型是 Flux<String>，代表一个"随时间产生的字符串流"
public Flux<String> streamMessage(Long userId, Long conversationId, ChatMessageRequest request) {
    
    // 1. 先把用户的提问保存到数据库
    saveUserMessage(conversationId, request.getContent());

    // 2. 准备一个容器，用来拼凑 AI 完整的回复（为了最后存数据库）
    StringBuilder fullContent = new StringBuilder();

    // 3. 调用 DeepSeek API
    return deepSeekClient.post()
            .uri("/v1/chat/completions")
            .bodyValue(Map.of(
                    "model", "deepseek-chat",
                    "stream", true,           // 关键点：开启流式模式
                    "messages", List.of(...)
            ))
            .retrieve()
            .bodyToFlux(String.class)         // 关键点：将响应体转换为流
            .map(this::parseContentFromChunk) // 解析每一小块 JSON 数据
            .doOnNext(fullContent::append)    // 拼凑完整回复
            .doOnComplete(() -> {
                // 流结束时，把完整的 AI 回复保存到数据库
                saveAiMessage(conversationId, fullContent.toString());
            });
}
```

### 2.3 API 接口暴露

我们需要一个“接待员”来接收前端的请求。

**核心代码 (ChatController.java)**:

```java
@RestController
@RequestMapping("/api")
public class ChatController {

    // 接收 POST 请求：/api/chat/{id}/stream
    // produces = TEXT_EVENT_STREAM_VALUE 表示这是一个 SSE 流接口
    @PostMapping(value = "/chat/{conversationId}/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> streamMessage(...) {
        return chatService.streamMessage(...);
    }
}
```

---

## 🎨 第三阶段：前端开发 - 打造精美的外观 (Vue 3)

前端使用 Vue 3 构建，为了追求极致速度，手写了原生的 CSS。

### 3.1 界面布局 (仿 DeepSeek)

文件位置：`frontend/src/views/Chat.vue`

布局采用经典的 **Flexbox** 布局：

* **Sidebar (左侧)**: 显示历史会话列表。宽度固定，可折叠。
* **Main (右侧)**: 聊天主区域。
  * **Header**: 显示当前标题。
  * **Message List**: 消息滚动区域 (`overflow-y: auto`)。
  * **Input Area**: 底部悬浮的输入框。

### 3.2 核心交互逻辑 (Fetch流式读取)

前端如何接收后端的“水流”？普通的 `axios` 等待整个响应，不适合流式。我们需要用原生的 `fetch` API。

**核心代码解析**:

```javascript
const onSend = async () => {
    // 1. 发起请求
    const response = await fetch(`/api/chat/${activeId.value}/stream`, {
        method: 'POST',
        body: JSON.stringify({ content: input.value })
    });

    // 2. 获取读取器
    const reader = response.body.getReader();
    const decoder = new TextDecoder(); // 用于把二进制数据转为文本

    // 3. 循环读取流
    while (true) {
        const { done, value } = await reader.read(); // 读一块数据
        if (done) break; // 读完了就退出

        // 4. 解码并追加到界面上
        const chunk = decoder.decode(value, { stream: true });
        // 这里的 chunk 可能是一个字，也可能是几个字
        currentAiMessage.content += chunk; 
        
        scrollToBottom(); // 自动滚动到底部
    }
};
```

### 3.3 主题切换 (深色模式)

我们使用 **CSS 变量 (CSS Variables)** 来实现换肤。

**CSS 定义**:

```css
:root {
  /* 默认浅色主题变量 */
  --bg-color: #ffffff;
  --text-color: #333333;
}

[data-theme='dark'] {
  /* 深色主题覆盖变量 */
  --bg-color: #1a1a1a;
  --text-color: #ffffff;
}
```

**JS 切换逻辑**:

```javascript
const toggleTheme = () => {
  isDark.value = !isDark.value;
  // 给 html 标签添加 data-theme="dark" 属性
  document.documentElement.setAttribute('data-theme', isDark.value ? 'dark' : 'light');
};
```

---

## 🚀 第四阶段：项目运行与调试

### 4.1 启动后端

1. 打开终端，进入 `backend` 文件夹。
2. 运行命令：`mvn clean spring-boot:run`。
3. 等待出现 `Tomcat started on port 8080`。

### 4.2 启动前端

1. 打开新终端，进入 `frontend` 文件夹。
2. 运行命令：`npm run dev`。
3. 终端会显示 `Local: http://localhost:5173/`。

### 4.3 浏览器访问

打开浏览器，访问 `http://localhost:5173`。尝试发送一条消息，你应该能看到文字一个个蹦出来的效果！

---

## 🧠 深度解析：技术背后的原理

### Q1: 为什么后端用了 WebFlux 而不是普通的 Spring MVC？

* **普通 Spring MVC**: 每个请求占用一个线程。如果 AI 回复需要 30 秒，这个线程就会卡死 30 秒。并发高了服务器就崩了。
* **WebFlux**: 异步非阻塞。线程发起请求后就去干别的事了，等 AI 有数据回来再通知线程处理。用极少的资源就能处理大量并发连接。

### Q2: 为什么前端不用 Axios？

* `Axios` 基于 `XMLHttpRequest`，虽然好用，但在处理流式响应（Stream）时比较麻烦，默认是等待所有数据下载完才返回。
* 原生 `fetch` API 的 `response.body.getReader()` 是专门为流式数据设计的，非常适合这种打字机效果。

---

**🎉 结语**
恭喜！你现在已经掌握了开发一个现代化 AI 聊天应用的所有核心技术。从数据库到后端流式接口，再到前端的流式渲染，这是一个完整的全栈闭环。
